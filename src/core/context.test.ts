import { describe, expect, test } from "bun:test";
import { generateProjectContext } from "./context.ts";
import { writeFile, mkdir, rm, readFile, chmod } from "fs/promises";
import { writeFileSync, mkdirSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";
import { getProjectClaudeMdPath } from "./config.ts";

describe("generateProjectContext", () => {
  const tmpDir = join(tmpdir(), "think-test-context-" + Date.now());

  async function setupProject(files: Record<string, string> = {}): Promise<string> {
    const projectDir = join(tmpDir, "project-" + Math.random().toString(36).slice(2, 8));
    await mkdir(join(projectDir, "src"), { recursive: true });

    // Create a basic package.json for project detection
    await writeFile(
      join(projectDir, "package.json"),
      JSON.stringify({
        name: "test-project",
        description: "A test project",
        dependencies: {},
      })
    );

    // Create a basic tsconfig for TypeScript detection
    await writeFile(
      join(projectDir, "tsconfig.json"),
      JSON.stringify({ compilerOptions: { target: "esnext" } })
    );

    for (const [path, content] of Object.entries(files)) {
      const fullPath = join(projectDir, path);
      await mkdir(join(fullPath, "..").replace(/\/\.\.$/, ""), { recursive: true });
      const dir = fullPath.substring(0, fullPath.lastIndexOf("/"));
      await mkdir(dir, { recursive: true });
      await writeFile(fullPath, content);
    }

    return projectDir;
  }

  test("generates context for a basic project", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export function main(): void { console.log('hello'); }",
      "src/utils.ts": "export function add(a: number, b: number): number { return a + b; }",
    });

    const result = await generateProjectContext(projectDir, { dryRun: true });

    expect(result.markdown).toContain("# test-project");
    expect(result.markdown).toContain("Generated by `think context`");
    expect(result.totalTokens).toBeGreaterThan(0);
    expect(result.sections.length).toBeGreaterThanOrEqual(2); // at least overview and structure

    // Should have overview section
    const overview = result.sections.find((s) => s.id === "overview");
    expect(overview).toBeTruthy();

    // Should have structure section
    const structure = result.sections.find((s) => s.id === "structure");
    expect(structure).toBeTruthy();

    await rm(projectDir, { recursive: true });
  });

  test("extracts code map from source files", async () => {
    const projectDir = await setupProject({
      "src/index.ts": `export function hello(name: string): string {
  return \`Hello \${name}\`;
}

export interface Config {
  name: string;
  value: number;
}

export type Status = "active" | "inactive";`,
    });

    const result = await generateProjectContext(projectDir, { dryRun: true });

    const codeMap = result.sections.find((s) => s.id === "codeMap");
    expect(codeMap).toBeTruthy();
    expect(codeMap!.content).toContain("hello");

    await rm(projectDir, { recursive: true });
  });

  test("respects custom budget", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export function main(): void {}",
    });

    const small = await generateProjectContext(projectDir, {
      dryRun: true,
      budget: 2000,
    });
    const large = await generateProjectContext(projectDir, {
      dryRun: true,
      budget: 20000,
    });

    // Both should work, but with different budget allocations
    expect(small.totalTokens).toBeGreaterThan(0);
    expect(large.totalTokens).toBeGreaterThan(0);

    await rm(projectDir, { recursive: true });
  });

  test("excludes test files from signatures by default", async () => {
    const projectDir = await setupProject({
      "src/main.ts": "export function main(): void {}",
      "src/main.test.ts":
        'import { describe, test } from "bun:test";\nexport function testHelper(): void {}',
    });

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const codeMap = result.sections.find((s) => s.id === "codeMap");

    // Test files should be excluded
    if (codeMap) {
      expect(codeMap.content).not.toContain("main.test.ts");
    }

    await rm(projectDir, { recursive: true });
  });

  test("includes key files when configured", async () => {
    const projectDir = await setupProject({
      "src/config.ts": "export const VERSION = '1.0.0';",
    });

    // Create .think.yaml with key_files config
    await writeFile(
      join(projectDir, ".think.yaml"),
      `context:
  key_files:
    - "src/config.ts"
`
    );

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const keyFiles = result.sections.find((s) => s.id === "keyFiles");
    expect(keyFiles).toBeTruthy();
    expect(keyFiles!.content).toContain("VERSION");

    await rm(projectDir, { recursive: true });
  });

  test("includes knowledge directory content", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    // Create knowledge directory with docs
    const knowledgeDir = join(projectDir, ".think", "knowledge");
    await mkdir(knowledgeDir, { recursive: true });
    await writeFile(join(knowledgeDir, "architecture.md"), "# Architecture\n\nMicroservices design.");

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const knowledge = result.sections.find((s) => s.id === "knowledge");
    expect(knowledge).toBeTruthy();
    expect(knowledge!.content).toContain("Microservices design");

    await rm(projectDir, { recursive: true });
  });

  test("writes to correct output path when not dry run", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    const result = await generateProjectContext(projectDir, { dryRun: false });
    const outputPath = getProjectClaudeMdPath(projectDir);

    const written = await readFile(outputPath, "utf-8");
    expect(written).toBe(result.markdown);

    // Clean up output
    await rm(outputPath, { recursive: true }).catch(() => {});
    await rm(projectDir, { recursive: true });
  });

  test("handles project with no source files", async () => {
    const projectDir = await setupProject({});

    const result = await generateProjectContext(projectDir, { dryRun: true });
    expect(result.markdown).toContain("# test-project");
    expect(result.totalTokens).toBeGreaterThan(0);
    // Should still have overview and structure
    expect(result.sections.find((s) => s.id === "overview")).toBeTruthy();

    await rm(projectDir, { recursive: true });
  });

  test("handles non-existent knowledge directory gracefully", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    // Configure a non-existent knowledge dir
    await writeFile(
      join(projectDir, ".think.yaml"),
      `context:
  knowledge_dir: "nonexistent/docs"
`
    );

    const result = await generateProjectContext(projectDir, { dryRun: true });
    // Should complete without error
    expect(result.markdown).toBeTruthy();
    const knowledge = result.sections.find((s) => s.id === "knowledge");
    // Knowledge section should not exist since dir doesn't exist
    expect(knowledge).toBeUndefined();

    await rm(projectDir, { recursive: true });
  });

  test("rejects knowledge directory with path traversal", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    await writeFile(
      join(projectDir, ".think.yaml"),
      `context:
  knowledge_dir: "../../etc"
`
    );

    const result = await generateProjectContext(projectDir, { dryRun: true });
    // Should not include knowledge from outside project
    const knowledge = result.sections.find((s) => s.id === "knowledge");
    expect(knowledge).toBeUndefined();

    await rm(projectDir, { recursive: true });
  });

  test("sanitizes project name in output", async () => {
    const projectDir = await setupProject({});

    // Override package.json with potentially malicious name
    await writeFile(
      join(projectDir, "package.json"),
      JSON.stringify({
        name: "# Injected\n## Heading\n```code```",
        dependencies: {},
      })
    );

    const result = await generateProjectContext(projectDir, { dryRun: true });
    // sanitizeMarkdownHeading collapses newlines into spaces and strips leading #
    // So "## Heading" won't appear on its own line as a real markdown heading
    expect(result.markdown).not.toMatch(/^## Heading$/m);
    // Backticks should be removed
    expect(result.markdown).not.toContain("```code```");

    await rm(projectDir, { recursive: true });
  });

  test("prioritizes entry point files in code map", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export function entryPoint(): void {}",
      "src/utils/helpers.ts": "export function helper(): void {}",
      "src/deep/nested/module.ts": "export function deepFunc(): void {}",
    });

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const codeMap = result.sections.find((s) => s.id === "codeMap");

    if (codeMap && codeMap.content) {
      // index.ts should appear before deeper files since it's an entry point
      const indexPos = codeMap.content.indexOf("index.ts");
      const deepPos = codeMap.content.indexOf("deep/nested/module.ts");
      if (indexPos !== -1 && deepPos !== -1) {
        expect(indexPos).toBeLessThan(deepPos);
      }
    }

    await rm(projectDir, { recursive: true });
  });

  test("truncates content when exceeding budget", async () => {
    const projectDir = await setupProject({});

    // Create many source files to exceed a very small budget
    for (let i = 0; i < 30; i++) {
      await writeFile(
        join(projectDir, "src", `module${i}.ts`),
        `export function func${i}(x: number): number { return x * ${i}; }\nexport interface Type${i} { value: number; name: string; }`
      );
    }

    const result = await generateProjectContext(projectDir, {
      dryRun: true,
      budget: 2000,
    });

    // Should still produce valid output within budget constraints
    expect(result.markdown).toBeTruthy();
    expect(result.sections.length).toBeGreaterThan(0);

    // Some files may have been truncated from code map
    // (truncated array collects dropped file paths)
    await rm(projectDir, { recursive: true });
  });

  test("handles monorepo project", async () => {
    const projectDir = await setupProject({});

    // Create a monorepo structure
    await writeFile(
      join(projectDir, "package.json"),
      JSON.stringify({
        name: "my-monorepo",
        workspaces: ["apps/*", "packages/*"],
      })
    );
    await writeFile(join(projectDir, "turbo.json"), "{}");
    await mkdir(join(projectDir, "apps", "web"), { recursive: true });
    await writeFile(
      join(projectDir, "apps", "web", "package.json"),
      JSON.stringify({
        name: "@mono/web",
        description: "Web frontend",
        dependencies: { react: "^18.0.0" },
      })
    );
    await mkdir(join(projectDir, "packages", "shared"), { recursive: true });
    await writeFile(
      join(projectDir, "packages", "shared", "package.json"),
      JSON.stringify({ name: "@mono/shared" })
    );

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const overview = result.sections.find((s) => s.id === "overview");
    expect(overview).toBeTruthy();
    expect(overview!.content).toContain("Monorepo");
    expect(overview!.content).toContain("Turborepo");
    expect(overview!.content).toContain("Workspaces");

    await rm(projectDir, { recursive: true });
  });

  test("handles large key file with truncation", async () => {
    const projectDir = await setupProject({});

    // Create a very large key file
    const bigContent = "export const x = " + "a".repeat(10000) + ";";
    await writeFile(join(projectDir, "src", "big.ts"), bigContent);
    await writeFile(
      join(projectDir, ".think.yaml"),
      `context:
  budget: 2000
  key_files:
    - "src/big.ts"
`
    );

    const result = await generateProjectContext(projectDir, { dryRun: true });
    // Should handle gracefully even if the file exceeds the key files budget
    expect(result.markdown).toBeTruthy();

    await rm(projectDir, { recursive: true });
  });

  test("shouldIgnore matches exact names from DEFAULT_IGNORE", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    // Create directories that match exact ignore patterns
    await mkdir(join(projectDir, "node_modules"), { recursive: true });
    await writeFile(join(projectDir, "node_modules", "pkg.js"), "");
    await mkdir(join(projectDir, "dist"), { recursive: true });
    await writeFile(join(projectDir, "dist", "bundle.js"), "");

    const result = await generateProjectContext(projectDir, { dryRun: true });
    // node_modules and dist should be ignored in tree and code map
    expect(result.markdown).not.toContain("node_modules");

    await rm(projectDir, { recursive: true });
  });

  test("filePriority scores type definition files higher", async () => {
    const projectDir = await setupProject({
      "src/types.ts": "export type Status = 'active' | 'inactive';",
      "src/deep/nested/util.ts": "export function util(): void {}",
    });

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const codeMap = result.sections.find((s) => s.id === "codeMap");
    if (codeMap && codeMap.content) {
      const typesPos = codeMap.content.indexOf("types.ts");
      const utilPos = codeMap.content.indexOf("deep/nested/util.ts");
      // types.ts should have higher priority and appear first
      if (typesPos !== -1 && utilPos !== -1) {
        expect(typesPos).toBeLessThan(utilPos);
      }
    }

    await rm(projectDir, { recursive: true });
  });

  test("handles .think.yaml with signature_depth 'all'", async () => {
    const projectDir = await setupProject({
      "src/index.ts": `function privateHelper(): void {}
export function publicApi(): void {}`,
    });

    await writeFile(
      join(projectDir, ".think.yaml"),
      `context:
  signature_depth: all
`
    );

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const codeMap = result.sections.find((s) => s.id === "codeMap");
    // With "all", private functions should be included
    if (codeMap) {
      expect(codeMap.content).toContain("privateHelper");
    }

    await rm(projectDir, { recursive: true });
  });

  test("includes multiple knowledge files sorted alphabetically", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    const knowledgeDir = join(projectDir, ".think", "knowledge");
    await mkdir(knowledgeDir, { recursive: true });
    await writeFile(join(knowledgeDir, "beta.md"), "# Beta\n\nBeta docs.");
    await writeFile(join(knowledgeDir, "alpha.md"), "# Alpha\n\nAlpha docs.");

    const result = await generateProjectContext(projectDir, { dryRun: true });
    const knowledge = result.sections.find((s) => s.id === "knowledge");
    expect(knowledge).toBeTruthy();
    // Both files should be included, sorted alphabetically (alpha before beta)
    const alphaPos = knowledge!.content.indexOf("Alpha docs");
    const betaPos = knowledge!.content.indexOf("Beta docs");
    expect(alphaPos).toBeGreaterThan(-1);
    expect(betaPos).toBeGreaterThan(-1);
    expect(alphaPos).toBeLessThan(betaPos);

    await rm(projectDir, { recursive: true });
  });

  test("handles knowledge directory that exists but fails readdir", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    // Create knowledge path as a file (not directory) â€” existsSync returns true
    // but readdir will throw ENOTDIR, exercising the catch block
    const knowledgeDir = join(projectDir, ".think", "knowledge");
    await mkdir(join(projectDir, ".think"), { recursive: true });
    await writeFile(knowledgeDir, "not a directory");

    const result = await generateProjectContext(projectDir, { dryRun: true });
    expect(result.markdown).toBeTruthy();
    // Knowledge section should not exist since readdir failed
    const knowledge = result.sections.find((s) => s.id === "knowledge");
    expect(knowledge).toBeUndefined();

    await rm(projectDir, { recursive: true });
  });

  test("handles unreadable subdirectory during walk", async () => {
    const projectDir = await setupProject({
      "src/index.ts": "export const x = 1;",
    });

    const unreadable = join(projectDir, "src", "private");
    await mkdir(unreadable, { recursive: true });
    await writeFile(join(unreadable, "secret.ts"), "export const s = 1;");
    await chmod(unreadable, 0o000);

    try {
      const result = await generateProjectContext(projectDir, { dryRun: true });
      expect(result.markdown).toBeTruthy();
      expect(result.markdown).toContain("index.ts");
    } finally {
      await chmod(unreadable, 0o755);
      await rm(projectDir, { recursive: true });
    }
  });
});
