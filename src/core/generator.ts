import { mkdir, writeFile, readFile, readdir, copyFile, rm } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import { homedir } from "os";
import { CONFIG, thinkPath, pluginPath } from "./config";
import { parseMarkdown } from "./parser";

/**
 * Generate the Claude plugin from ~/.think sources
 */
export async function generatePlugin(): Promise<void> {
  // Clean and create plugin directory
  if (existsSync(CONFIG.pluginDir)) {
    await rm(CONFIG.pluginDir, { recursive: true });
  }
  await mkdir(CONFIG.pluginDir, { recursive: true });
  await mkdir(pluginPath(".claude-plugin"), { recursive: true });
  await mkdir(pluginPath("skills"), { recursive: true });
  await mkdir(pluginPath("agents"), { recursive: true });
  await mkdir(pluginPath("hooks"), { recursive: true });

  // Generate plugin.json manifest
  await generateManifest();

  // Generate CLAUDE.md
  await generateClaudeMd();

  // Copy skills
  await copyDirectory(thinkPath(CONFIG.dirs.skills), pluginPath("skills"));

  // Copy agents
  await copyDirectory(thinkPath(CONFIG.dirs.agents), pluginPath("agents"));

  // Generate hooks
  await generateHooks();

  // Register plugin in Claude settings
  await registerPlugin();
}

async function generateManifest(): Promise<void> {
  const manifest = {
    name: "think",
    version: "0.1.0",
    description: "Personal context and preferences for Claude",
    skills: "../skills/",
    agents: "../agents/",
    hooks: "../hooks/",
  };

  await writeFile(
    pluginPath(".claude-plugin", "plugin.json"),
    JSON.stringify(manifest, null, 2)
  );
}

async function generateClaudeMd(): Promise<void> {
  const sections: string[] = [];

  sections.push("# Personal Context\n");
  sections.push("This context is auto-generated by `think`. Do not edit directly.\n");

  // Profile
  const profile = await parseMarkdown(thinkPath(CONFIG.files.profile));
  if (profile?.content) {
    sections.push("## About the User\n");
    sections.push(profile.content);
    sections.push("");
  }

  // Tool preferences
  const tools = await parseMarkdown(thinkPath(CONFIG.files.tools));
  if (tools?.content) {
    sections.push("## Tool Preferences\n");
    sections.push(tools.content);
    sections.push("");
  }

  // Patterns
  const patterns = await parseMarkdown(thinkPath(CONFIG.files.patterns));
  if (patterns?.content) {
    sections.push("## Patterns to Follow\n");
    sections.push(patterns.content);
    sections.push("");
  }

  // Anti-patterns
  const antiPatterns = await parseMarkdown(thinkPath(CONFIG.files.antiPatterns));
  if (antiPatterns?.content) {
    sections.push("## Anti-Patterns to Avoid\n");
    sections.push(antiPatterns.content);
    sections.push("");
  }

  // Learnings
  const learnings = await parseMarkdown(thinkPath(CONFIG.files.learnings));
  if (learnings?.content) {
    sections.push("## Memory - Learnings\n");
    sections.push(learnings.content);
    sections.push("");
  }

  // Corrections
  const corrections = await parseMarkdown(thinkPath(CONFIG.files.corrections));
  if (corrections?.content) {
    sections.push("## Memory - Corrections\n");
    sections.push(corrections.content);
    sections.push("");
  }

  // Subagent automation
  const subagents = await parseMarkdown(thinkPath(CONFIG.files.subagents));
  if (subagents?.content) {
    sections.push("## Automation - Subagents\n");
    sections.push("Follow these rules for automatically spawning subagents:\n");
    sections.push(subagents.content);
    sections.push("");
  }

  // Workflows
  const workflows = await parseMarkdown(thinkPath(CONFIG.files.workflows));
  if (workflows?.content) {
    sections.push("## Automation - Workflows\n");
    sections.push(workflows.content);
    sections.push("");
  }

  await writeFile(pluginPath(CONFIG.plugin.claudeMd), sections.join("\n"));
}

async function generateHooks(): Promise<void> {
  // Generate permission hook for allowed commands
  const allowedCommands = await parseMarkdown(thinkPath(CONFIG.files.allowedCommands));

  if (allowedCommands?.content) {
    const hookContent = `---
name: auto-approve-commands
description: Auto-approve pre-configured safe commands
event: PreToolUse
tools:
  - Bash
---

# Auto-Approve Commands

The user has pre-approved these commands. If the current Bash command matches any of these patterns, approve it automatically.

${allowedCommands.content}

If the command matches one of the above, respond with: APPROVE

If the command does not match, respond with: PASSTHROUGH
`;

    await writeFile(pluginPath("hooks", "auto-approve-commands.md"), hookContent);
  }

  // Generate hook for Claude to suggest learnings
  const suggestLearningHook = `---
name: suggest-learning
description: Allows Claude to suggest learnings for the user to review
event: Stop
---

# Suggest Learning

If during this session you discovered something important about the user's preferences, patterns, or corrections that should be remembered for future sessions, you may suggest it as a learning.

To suggest a learning, include a line in your response in this exact format:
[THINK_SUGGEST]: <your learning here>

The user will review and approve/reject these suggestions via \`think review\`.

Only suggest learnings that are:
- Specific and actionable
- About the user's preferences, not general knowledge
- Not already captured in the existing memory

Be selective - only suggest truly valuable learnings.
`;

  await writeFile(pluginPath("hooks", "suggest-learning.md"), suggestLearningHook);
}

async function copyDirectory(src: string, dest: string): Promise<void> {
  if (!existsSync(src)) return;

  const entries = await readdir(src, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.isFile() && entry.name.endsWith(".md")) {
      await copyFile(join(src, entry.name), join(dest, entry.name));
    }
  }
}

async function registerPlugin(): Promise<void> {
  const claudeDir = join(homedir(), ".claude");
  const settingsPath = join(claudeDir, "settings.json");
  const installedPluginsPath = join(claudeDir, "plugins", "installed_plugins.json");

  // 1. Update settings.json to enable the plugin
  let settings: Record<string, unknown> = {};
  if (existsSync(settingsPath)) {
    try {
      const content = await readFile(settingsPath, "utf-8");
      settings = JSON.parse(content);
    } catch {
      settings = {};
    }
  }

  if (!settings.enabledPlugins) {
    settings.enabledPlugins = {};
  }
  (settings.enabledPlugins as Record<string, boolean>)["think@local"] = true;

  await writeFile(settingsPath, JSON.stringify(settings, null, 2));

  // 2. Update installed_plugins.json to register the plugin
  let installedPlugins: Record<string, unknown> = { version: 2, plugins: {} };
  if (existsSync(installedPluginsPath)) {
    try {
      const content = await readFile(installedPluginsPath, "utf-8");
      installedPlugins = JSON.parse(content);
    } catch {
      installedPlugins = { version: 2, plugins: {} };
    }
  }

  const plugins = installedPlugins.plugins as Record<string, unknown[]>;
  plugins["think@local"] = [
    {
      scope: "user",
      installPath: CONFIG.pluginDir,
      version: "local",
      installedAt: new Date().toISOString(),
      lastUpdated: new Date().toISOString(),
    },
  ];

  await writeFile(installedPluginsPath, JSON.stringify(installedPlugins, null, 2));
}
